<div align="center">
<h1>Grain: A Programming Language For The Super Nintendo Entertainment System</h1>
<img 
    src="misc/DALL.E_2.0_logo.png"
    width="200"
>
</div>
Logo generated by DALL-E 2.0

### What is Grain
Grain is my masters dissertation project. It is a compiler from a custom programming language, targeting the
 SNES. It has features such as automatic png loading and conversion built into it, so that users don't need 
to know hardware specifics. This also means users don't need to keep track of a number of other utility 
projects, as all the tools you need are baked into the language itself. 

If you *want* to use other conversion tools you still can. Grain has inbuilt support for loading binary files.

It also provides a fairly basic assembly standard library to interface with hardware details. This means users don't 
have to know what registers and tricks are being used under the hood, they can just call a function and be done with it. 

If you have done some assembly on SNES before and find yourself adding to this library, I am more than open for pull requests.

### How to use it
See [this file](misc/language_explanation.md) for information on the programming language. 

If someone knows how to compile Scala 3 from IntelliJ Ultimate, please open an issue and tell me. 
The only help I can find on Stack Overflow is someone saying not to use IntelliJ Ultimate with the most 
sarcastic emoji the cespits of the internet provides.

The entire IntelliJ Ultimate project is included in this repo, if you boot it up and alter the 
`filename` variable in `src/main/scala/TreeWalker/GrainTranslator`'s `main` function, it will work fine.

The project uses bsnes-plus as an emulator for the produced ROMs, and the WLA assembler to assemble the assembly produced
(thats a sentence). Both come with the project, through they will probably become submodules when I get round to it. Currently 
prepping for my viva so the project is a little messy. If you want to use other programs, grain_config.json contains some values that 
can be tweaked for this.

### To do
Having worked 15 hour (and a few 17 hour) days on this in the runup to the deadline, I probably won't get round 
to any of this soon. I'm both burned out, and want to mess about with some other projects.

Regardless, here are the things that could be improved
- [ ] Like with `hiram`, change some address mode generation to let you read values from ROM
- [ ] By using some available tools to create binary files and with an extention to the standard library provided,
 you would be able to get sound working from files. This is a better approach that making a secondary compiler for 
the audio units machine code.
- [ ] Some tree optimisations. All current optimisations are only keyhole optimisations on the generated, low level IR.
- [ ] Language features like a const keyword and function pointers would be nice. With function pointers, the 
structs could behave kind of like classes thanks to how member functions work under the hood.