load backgroundSprites, backgroundPalette from "SnakeBackground.png"
load snakeSprites, snakePalette from "SnakePlayfield.png"

include "src/main/GrainLib/DMA.grain"
include "src/main/GrainLib/Hardware.grain"
include "src/main/GrainLib/Backgrounds.grain"
include "src/main/GrainLib/Random.grain"

playerInput: Input

background: word[32][32]

class SnakeBuffer{
    x: word[600]
    y: word[600]
}
class Vec2{
    x: word
    y: word
}

snakeBuffer: SnakeBuffer
playerVelocity: Vec2
lastFruit: Vec2

tailIndex: word = 0
headIndex: word = 2

emptyTile: word = 15
snakeBodyTile: word = 16
snakeHeadTile: word = 17
snakeTailTile: word = 18
fruitTile: word = 19

gameRunning: bool = true

func setTile(x: word, y: word, tileID: word){
    x = x + 1
    y = y + 5
    background[y][x] = tileID
}
func getTile(x: word, y: word): word{
    x = x + 1
    y = y + 5
    return background[y][x]
}
func isSnakeTile(x: word, y: word): bool{
    atTileID: word = getTile(x, y)
    return atTileID == snakeHeadTile or atTileID == snakeBodyTile or atTileID == snakeTailTile
}
func spawnFruit(){
    x: word = random() & 0xF
    y: word = random() & 0xF

    if x > 30 then x = 10
    if y > 30 then y = 10

    if isSnakeTile(x, y) or (x == lastFruit.x and y == lastFruit.y) then{
        spawnFruit()
    }
    else{
        setTile(x, y, fruitTile)
        lastFruit.x = x
        lastFruit.y = y
    }
}

func sendDataToBackground2(){
    setVRamTarget(0x800)
    dmaToVRam(background as tile_data ptr, 0 as data_bank, 2048)
    executeDMA()
}


func detailBackground1(){
    textLine: word ptr = background[3][1]@
    i: word = 0
    index: word = 3
    for ; i < 6; i = i + 1 do{
        textLine[i] = index
        index = index + 1
    }
}

func initBackground1(){
    //First 5 lines (with cast to make it slightly faster
    for i: word = 0; i < 160; i = i + 1 do
        (background as word[1024])[i] = emptyTile

    topLine: word ptr = background[5][0]@
    topLine[0] = emptyTile
    for i: word = 1; i < 31; i = i + 1 do topLine[i] = 2
    topLine[31] = emptyTile

    y: word = 6
    for ; y < 26; y = y + 1 do{
        line: word ptr = background[y][0]@
        line[0] = 1
        line[31] = emptyTile
        for x: word = 1; x < 31; x = x + 1 do line[x] = 0
    }
    for ; y < 32; y = y + 1 do
        for x: word = 0; x < 32; x = x + 1 do
            background[y][x] = emptyTile

    detailBackground1()
    setBackgroundAddressAndSize(2, 1, 0)
}

func initSnake(){
    for i: word = 0; i < 1024; i = i + 1 do
        (background as word[1024])[i] = emptyTile
    for i: word = 0; i < 1200; i = i + 1 do
        (snakeBuffer as word[1200])[i] = 0

    snakeBuffer.x[0] = 20
    snakeBuffer.x[1] = 20
    snakeBuffer.x[2] = 20
    snakeBuffer.y[0] = 11
    snakeBuffer.y[1] = 10
    snakeBuffer.y[2] = 9

    setTile(20, 11, snakeTailTile)
    setTile(20, 10, snakeBodyTile)
    setTile(20, 9, snakeHeadTile)

    playerVelocity.x = 0
    playerVelocity.y = -1

    setBackgroundAddressAndSize(1, 2, 0)
}

func setup(){
    setScreenDisabledAndBrightness(true, 0)
    dmaToVRam(backgroundSprites, bankof(backgroundSprites), sizeof(backgroundSprites))
    dmaToCGRam(snakePalette, bankof(snakePalette), 64)
    executeDMA()

    dmaToVRam(snakeSprites, bankof(snakeSprites), sizeof(snakeSprites))
    dmaToCGRam(backgroundPalette, bankof(backgroundPalette), 32)
    executeDMA()

    setBackgroundColour(ascolour(0, 7, 2, 0))

    setVRamTarget(0x400)
    initBackground1()
    dmaToVRam(background as tile_data ptr, 0 as data_bank, 2048)
    executeDMA()

    initSnake()
    lastFruit.x = -1
    lastFruit.y = -1
    spawnFruit()
    sendDataToBackground2()

    enableScreens(true, true, false, false, false)
    enableInputAndNMI()
    setScreenDisabledAndBrightness(false, 15)
}

func updatePlayerDirectionalOffset(){
    if playerInput.Left then{
        playerVelocity.x = -1
        playerVelocity.y = 0
    }
    else if playerInput.Right then{
        playerVelocity.x = 1
        playerVelocity.y = 0
    }
    else if playerInput.Up then{
        playerVelocity.x = 0
        playerVelocity.y = -1
    }
    else if playerInput.Down then{
        playerVelocity.x = 0
        playerVelocity.y = 1
    }
}

func updateFrame(){
    updatePlayerInput(playerInput@, 1)
    updatePlayerDirectionalOffset()

    headX: word = snakeBuffer.x[headIndex]
    headY: word = snakeBuffer.y[headIndex]
    newX: word = headX + playerVelocity.x
    newY: word = headY + playerVelocity.y

    if newX >= 0 and newY >= 0 and newX < 30 and newY < 20 and getTile(newX, newY) != snakeBodyTile then{
        ateFruit: bool = getTile(newX, newY) == fruitTile
        if !ateFruit then setTile(snakeBuffer.x[tailIndex], snakeBuffer.y[tailIndex], emptyTile)
        setTile(newX, newY, snakeHeadTile)
        setTile(headX, headY, snakeBodyTile)
        headIndex = headIndex + 1
        if !ateFruit then{
            tailIndex = tailIndex + 1
            if tailIndex == 600 then tailIndex = 0
            setTile(snakeBuffer.x[tailIndex], snakeBuffer.y[tailIndex], snakeTailTile)
        }
        else{
            spawnFruit()
        }
        if headIndex == 600 then headIndex = 0
        snakeBuffer.x[headIndex] = newX
        snakeBuffer.y[headIndex] = newY
    }
    else gameRunning = false

    for i: word = 0; i < 8; i = i + 1 do{
        updatePlayerInput(playerInput@, 1)
        updatePlayerDirectionalOffset()
        frame()
    }
}

func addGameOverText(){
    background[3][12] = 20
    background[3][13] = 21
    background[3][14] = 22
    background[3][15] = 23
    background[3][16] = 24
    background[3][17] = 25
    background[3][18] = 23
    background[3][19] = 26
}

func main(){
    setSeed(0x92A6)//Certainly not a homestuck reference
    setup()

    while gameRunning do updateFrame()

    addGameOverText()

    while true do frame()
}

func VBlank(){
    sendDataToBackground2()
}